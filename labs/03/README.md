# Лабораторная работа №3

- [Лабораторная работа №3](#лабораторная-работа-3)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — signal-handler — 50 баллов](#задание-1--signal-handler--50-баллов)
    - [Задание 2 — Иван Грозный убивает своего сына — 70 баллов](#задание-2--иван-грозный-убивает-своего-сына--70-баллов)
    - [Задание 3 — Pipes — 120 баллов](#задание-3--pipes--120-баллов)
      - [Подсказки](#подсказки)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 50 баллов.
- На оценку хорошо нужно набрать не менее 100 баллов.
- Для получения оценки "отлично" нужно набрать не менее 200 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — signal-handler — 50 баллов

Разработайте кроссплатформенную программу **signal-handler**, которая
создаёт в текущем каталоге файл *temp.txt*, а затем каждую секунду выводит
в стандартный поток последовательные числа от 0 до 100.
В конце своей работы программа должна удалить файл *temp.txt* и вывести текст
«Done».

Чтобы сделать паузу, используйте функцию [`std::this_thread::sleep_for`](https://en.cppreference.com/w/cpp/thread/sleep_for).
Чтобы удалить файл, используйте функцию [`std::filesystem::remove`](https://en.cppreference.com/w/cpp/filesystem/remove).

Если во время работы программы нажать Ctrl+C, то программа завершит работу,
не выполнив завершающих действий: не удалит временный файл *temp.txt* и не выведет текст «Done».
То же самое произойдёт и при команды `kill id-процесса`.

Используйте механизмы обработки сигналов, чтобы ваша программа могла обработать сигнал о прерывании работы и завершить работу.

Вам пригодится функция [`signal`](https://man7.org/linux/man-pages/man2/signal.2.html) (реализована под Windows и Linux)
или [`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html)
(последняя не реализована под Windows), чтобы задать обработчик сигналов.

Задайте обработчики сигналов `SIGINT` (прерывание работы программы с клавиатуры)
и `SIGTERM` (сигнал о завершении работы программы).

В обработчике сигнала установите флаг, который периодически проверяется в программе,
чтобы сообщить ей о необходимости завершения работы.

Внимание, под ОС Windows обработчик сигнала вызывается в отдельном потоке.
Под Linux обработчик вызывается в основном потоке.
Чтобы избежать состояния гонки при конкурентном обращении нескольких потоков к флагу завершения,
сделайте флаг атомарной переменной. Для этого подойдут типы
[`std::atomic_flag`](https://en.cppreference.com/w/cpp/atomic/atomic_flag)
или [`std::atomic_bool`](https://en.cppreference.com/w/cpp/atomic/atomic).

```c++

// Этот глобальный флаг будет установлен при получении сигналов SIGINT и SIGTERM
std::atomic_flag exitRequested;

void SignalHandler(int s)
{
  if (s == SIGINT || s == SIGTERM)
  {
    std::cout << "Process " << getpid() << " has received signal #" << s << "\n";
    // Атомарно устанавливаем флаг exitRequested
    exitRequested.test_and_set();
  }
}

int main()
{
  signal(SIGINT, SignalHandler);
  signal(SIGTERM, SignalHandler);

  // Так можно узнать, был ли установлен флаг завершения
  if (exitRequested.test())
  {
    // Программа получила сигнал о завершении
  }
}
```

Изучите работу команды [`kill`](https://man7.org/linux/man-pages/man1/kill.1.html)
и [`ps`](https://man7.org/linux/man-pages/man1/ps.1.html).
Запустите в одном окне консоли Lunux экземпляр вашей программы,
а в другом окне узнайте ёё pid командой `ps`.
Используйте `kill`, чтобы завершить работу процесса. Убедитесь, что процесс завершился штатным образом.

### Задание 2 — Иван Грозный убивает своего сына — 70 баллов

Ознакомьтесь с работой функции [`kill`](https://man7.org/linux/man-pages/man2/kill.2.html).
Напишите Linux-программу **kill-child**, которая считывает со стандартного ввода команды и выполняет их.

- Команда `exit` завершает работу программы.
- Команда `spawn` запускает дочерний процесс функцией `fork`.
  Дочерний процесс должен ждать сигналы SIGTERM и SIGINT и
  каждые 5 секунд выводить надпись «Child process ID-процесса is still alive».
- Команда `kill` посылает сигнал SIGTERM очередному дочернему процессу и дожидается его завершения.
  Если дочерних процессов не осталось, выведите сообщение: «No children to kill»

Если родительский процесс завершил работу, а дочерние ещё нет,
используйте команду `kill` в другом окне консоли, чтобы завершить их.

### Задание 3 — Pipes — 120 баллов

Изучите работу функций
[`pipe`](https://man7.org/linux/man-pages/man7/pipe.7.html),
[`read`](https://man7.org/linux/man-pages/man2/read.2.html),
[`write`](https://man7.org/linux/man-pages/man2/write.2.html),
[`close`](https://man7.org/linux/man-pages/man2/close.2.html).
Напишите программу **pipes**, которая запускает дочерний процесс с помощью `fork` и делегирует ему выполнение команд.

Родительский процесс считывает из stdin команды пользователя.
Дочерний процесс выполняет некоторые из них.

Команда `exit` не имеет параметров и служит для завершения работы программы.
Дочерний процесс должен также завершить работу.

Команда `add` принимает произвольное (0 и больше) целых чисел.
Родительский процесс должен поручить дочернему процессу
вычислить сумму массива целых чисел.
Дочерний процесс должен вычислить их сумму и вернуть родительскому процессу.
Родительский процесс должен вывести полученный результат.

В ответ на следующую команду

```txt
add 1 2 3 -4
```

должен быть выведен результат

```txt
sum is 2
```

Вычисление суммы должно произойти в дочернем процессе.

Команда `longest_word` принимает имя файла.
Родительский процесс должен поручить дочернему процессу найти самое длинное слово в указанном файле.
Дочерний процесс должен прочитать файл, найти в нём самое длинное слово и вернуть его родительскому процессу.
Если длинных слов-кандидатов несколько, должно быть возвращено первое среди них,
а если слов нет, то пустая строка.
Родительский процесс должен вывести это слово.

В ответ на следующую команду:

```txt
longest_word file.txt
```

должно быть выведено первое среди самых длинных слов файла file.txt

#### Подсказки

- Вызовите функцию `pipe` дважды, чтобы получить два канала:
  - Первый канал используйте для отправки команд от родителя к потомку
  - Второй канал используйте для отправки результатов от потомка родителю
- Передать сложные объекты вроде `std::string` или `std::vector`
  из одного процесса в другой не выйдет (попробуйте догадаться, почему).
  Вам надо преобразовать их в последовательность байтов,
  которую можно передать через pipe и восстановить на другом «конце провода».
- Чтобы можно было преобразовывать последовательность байтов в структуру,
  используйте функцию [`std::bit_cast`](https://en.cppreference.com/w/cpp/numeric/bit_cast):
- Для безопасной работы с файловыми дескрипторами, возвращаемыми функцией pipe, разработайте RAII-обёртку.
  Уделите внимание их конструкторам копирования и перемещения, также операциям присваивания.
- Для работы с непрерывными диапазонами данных в памяти может пригодиться [`std::span`](https://en.cppreference.com/w/cpp/container/span).
- Для информирования об ошибках воспользуйтесь классом [`std::system_error`](https://en.cppreference.com/w/cpp/error/system_error).

  ```c++
  if (auto bytesWritten = write(desc, buffer, size); bytesWritten == -1)
  {
    // Выбрасываем system_error, который хранит системный код ошибки
    throw std::system_error(errno, std::generic_category());
  }
  ```
