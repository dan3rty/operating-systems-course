# Лабораторная работа №4

- [Лабораторная работа №4](#лабораторная-работа-4)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — flip-case-mt — 60 баллов](#задание-1--flip-case-mt--60-баллов)
      - [Указания](#указания)
    - [Задание 2 — tic-tac — 40 баллов](#задание-2--tic-tac--40-баллов)
      - [Подсказки](#подсказки)
    - [Задание 3 — sorter — 100 баллов](#задание-3--sorter--100-баллов)
      - [Подсказки](#подсказки-1)

## Задания

Ознакомьтесь со стандартными классами [`std::thread`](https://en.cppreference.com/w/cpp/thread/thread)
и [`std::jthread`](https://en.cppreference.com/w/cpp/thread/jthread).
Используйте их, чтобы выполнить предложенные задания.

- Для получения оценки "удовлетворительно" нужно набрать не менее 50 баллов.
- Для получения оценки "хорошо" нужно набрать не менее 90 баллов.
- Для получения оценки "отлично" нужно набрать не менее 180 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — flip-case-mt — 60 баллов

Напишите программу **flip-case-mt**, которая меняет регистр символов внутри входных файлов на противоположный.
Функционал программы аналогичен работе программы **flip-case** из лабораторной работы №2.
Различия заключаются в том, что вместо порождения дочерних процессов
ваша программа должна создавать рабочие потоки в рамках текущего процесса.

Программе через командную строку передаются имена входных файлов.
Имя выходного файла получается путём добавления расширения *.out* к имени входного файла.

Например, следующая команда должна создать файлы *input1.txt.out* и *input2.txt.out*, на основе файлов
*input1.txt* и *input2.txt*.

```bash
flip-case-mt input1.txt input2.txt
```

#### Указания

Для асинхронного запуска потоков используйте класс `std::jthread`.
В своем конструкторе он принимает функцию, которая будет выполнена в фоновом потоке.
В деструкторе он дожидается завершения потока.

Помещайте объекты `std::jthread` внутрь `std::vector`.
При разрушении вектора будут вызваны деструкторы находящихся в нём объектов, которые дождутся окончания работы потоков.

### Задание 2 — tic-tac — 40 баллов

Напишите программу async-counter, в которой главный поток программы порождает два дочерних потока.

- Первый поток в цикле выводит строчку «Tic» с интервалом в 2 секунды.
- Второй поток в цикле выводит строчку «Tac» с интервалом в 3 секунды.
- Главный поток ожидает ввода любой строки.
После того, как пользователь ввёл любую строку потоки "Тик" и "Так" должны вывести строку
«Tic thread completed» и «Tac thread completed», соответственно, и завершить свою работу.

Строчки "Tic" и "Tac" должны предваряться текущим локальным временем, чтобы было понятно, с каким интервалом выводятся надписи.

```txt
> 18:00:00 Tic
> 18:00:00 Tac
> 18:00:02 Tic
> 18:00:03 Tac
> 18:00:04 Tic
> 18:00:06 Tic
> 18:00:06 Tac
```

#### Подсказки

Одновременный вывод в stdout из нескольких потоков может приводить к перемешиванию выводимых данных.
Чтобы избежать этого, используйте класс [`std::osyncstream`](https://en.cppreference.com/w/cpp/io/basic_osyncstream),
чтобы решить эту проблему.

Используйте классы [`std::stop_token`](https://en.cppreference.com/w/cpp/thread/stop_token)
 и [`std::stop_source`](https://en.cppreference.com/w/cpp/thread/stop_token), чтобы сообщить фоновым потокам
о необходимости завершить работу.

Возможность вывода `time_point` и `duration` в `std::ostream` реализована в компиляторе MSVC в полной мере.
 В g++ — начиная с 13 версии.
 Вы можете воспользоваться следующей функцией, чтобы вывести текущее время даже в более старых компиляторах.

```c++
#include <sstream>
#include <iomanip>
#include <string>

using namespace std::literals;
using Clock = std::chrono::system_clock;

std::string CurrentTimeToString()
{
    auto t = Clock::to_time_t(Clock::now());
    struct tm buf;
#ifdef _MSC_VER
    localtime_s(&buf, &t);
#else
    localtime_r(&t, &buf);
#endif
    std::ostringstream os;
    os << std::setw(2) << std::setfill('0') << buf.tm_hour << ":" << buf    tm_min << ":" << buf.tm_sec;
    return std::move(os).str();
}
```

### Задание 3 — sorter — 100 баллов

Разработайте консольное приложение **sorter**, которое генерирует массив псевдослучайных
64-разрядных целых чисел заданного размера,
сортирует его и записывает в выходной файл.

Программа должна поддерживать работу в трех режимах:

- Вывод справки об использовании. Запускается с ключом командной строки `-h` или `--help`.
- Генерирование массива целых чисел заданного размера. Синтаксис командной строки:
  
  ```bash
  sorter generate OUTPUT_FILE SIZE`
  ```

  Числа в файле разделяются символом конца строки.
- Многопоточная сортировка массива целых чисел из файла, сгенерированного предыдущей командой.
  Запускается с ключом командной строки:
  
  ```bash
  sorter sort INPUT_FILE OUTPUT_FILE NUM_THREADS
  ```

  Параметр `NUM_THREADS` задаёт максимальное количество потоков, которое программа должна использовать для сортировки.
  
При запуске в режиме сортировки программа сначала должна загрузить массив, отсортировать его массив в одном потоке,
затем в двух, и так далее до `NUM_THREADS` включительно. На каждом шаге должен сортироваться оригинальный массив.
После каждой сортировки программа должна вывести время, затраченное на сортировку
с использованием заданного количества потоков.

В конце программа должна записать отсортированный массив на диск.

Вам дана заготовка программы, которая делает командную строку и генерирует файл со случайными данными.
Вам нужно реализовать многопоточную сортировку.

В дополнение к программе постройте таблицу и 3 диаграммы,
которые отображают зависимость времени сортировки от количества потоков:

- Массив из 1 миллиона элементов. Количество потоков от 0 до 32.
- Массив из 10 миллионов элементов. Количество потоков от 0 до 32.
- Массив из 100 миллионов элементов. Количество потоков от 0 до 32.

Сравните ускорение, которое вам удалось получить при N потоках по сравнению с однопоточным вариантом.
Сделайте выводы по полученным результатам.

#### Подсказки

Чтобы замерить время работы программы, используйте класс [`std::chrono::high_precision_clock`](https://en.cppreference.com/w/cpp/chrono/high_resolution_clock).

Чтобы отсортировать массив в несколько потоков, используйте сортировку слиянием:

- Разбейте массив на N диапазонов примерно одинакового размера.
- Каждый из этих диапазонов отсортируйте в N потоках (включая текущий) алгоритмом `std::sort`.
- Затем параллельно слейте каждую пару соседних отсортированных диапазонов в один
  алгоритмом [`std::inplace_merge`](https://en.cppreference.com/w/cpp/algorithm/inplace_merge).
  Получится $N/2$ диапазонов большего размера.
- Повторяйте предыдущий шаг, пока не получится один отсортированный диапазон, равный целому массиву.
- Отсортировав массив, убедитесь при помощи макроса `assert` и алгоритма `std::is_sorted`, что массив действительно отсортирован.

Используйте класс `std::jthread`, для запуска фоновых потоков.

Замеряйте время сортировки замеряйте в Release-конфигурации. Включите в компьютере режим максимальной производительности.
