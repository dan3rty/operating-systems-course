# Лабораторная работа №5

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее X баллов.
- Для получения оценки "хорошо" нужно набрать не менее Y баллов.
- Для получения оценки "отлично" нужно набрать не менее Z баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — Менеджер памяти — 100 баллов

Разработайте класс `MemoryManager`, позволяющий динамически выделять и освобождать память
внутри блока памяти, переданного ему в конструктор.

Для класса разработайте необходимый набор юнит-тестов.

```c++
#include <cassert>
#include <memory>
#include <utility>

class MemoryManager
{
public:
    // Инициализирует менеджер памяти непрерывным блоком size байт,
    // начиная с адреса start.
    // Возвращает true в случае успеха и false в случае ошибки
    // Методы MemAlloc и MemFree должны работать с этим блоком памяти для хранения данных.
    // Указатель start должен быть выровнен по адресу, кратному sizeof(std::max_align_t)
    MemoryManager(void* start, size_t size) noexcept
    {
    }

    MemoryManager(const MemoryManager&) = delete;
    MemoryManager& operator=(const MemoryManager&) = delete;

    // Выделяет блок памяти внутри размером size байт и возвращает адрес выделенного
    // блока памяти. Возвращённый указатель должен быть выровнен по адресу, кратному align.
    // Параметр align должен быть степенью числа 2.
    // В случае ошибки (нехватка памяти, невалидные параметры) возвращает nullptr.
    // Полученный таким образом блок памяти должен быть позднее освобождён методом Free
    void* Allocate(size_t size, size_t align = sizeof(std::max_align_t)) noexcept
    {
        return nullptr;
    }

    // Освобождает область памяти, ранее выделенную методом Allocate,
    // делая её пригодной для повторного использования. После этого указатель
    // перестаёт быть валидным.
    // Если addr — нулевой указатель, метод не делает ничего
    // Если addr — не является валидным указателем, возвращённым ранее методом Allocate,
    // поведение метода не определено.
    void Free(void* addr) noexcept
    {
    }
};

int main()
{
    alignas(sizeof(max_align_t)) char buffer[1000];

    MemoryManager memoryManager(buffer, std::size(buffer));

    auto ptr = memoryManager.Allocate(sizeof(double));

    auto value = std::construct_at(static_cast<double*>(ptr), 3.1415927);
    assert(*value == 3.1415927);
        
    memoryManager.Free(ptr);
}
```

#### Бонус: сделать менеджер памяти потокобезопасным — 50 баллов

Методы класса `MemoryManager` должно быть возможно безопасно вызывать из нескольких потоков одновременно.
Разработайте модульные тесты для проверки этого функционала.

### Задание 2

### Задание 3
